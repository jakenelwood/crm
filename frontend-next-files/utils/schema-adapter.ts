/**
 * SCHEMA ADAPTER UTILITY
 * 
 * This utility provides functions to adapt between the old schema and the new normalized schema.
 * It helps maintain backward compatibility during the transition period.
 */

import { Lead, LeadStatus, InsuranceType } from "@/types/lead";
import { Client } from "@/types/client";

/**
 * Adapts a lead from the new normalized schema to a format compatible with the old schema
 * This ensures that components expecting the old schema structure can still work
 * with data from the new schema.
 */
export function adaptLeadForLegacyComponents(lead: Lead): Lead {
  // Create a copy of the lead to avoid mutating the original
  const adaptedLead = { ...lead };
  
  // If we have a client object, extract the relevant fields for backward compatibility
  if (lead.client) {
    adaptedLead.first_name = lead.client.name.split(' ')[0] || '';
    adaptedLead.last_name = lead.client.name.split(' ').slice(1).join(' ') || '';
    adaptedLead.email = lead.client.email;
    adaptedLead.phone_number = lead.client.phone_number;
    
    // Add address fields if available
    if (lead.client.address) {
      adaptedLead.street_address = lead.client.address.street;
      adaptedLead.city = lead.client.address.city;
      adaptedLead.state = lead.client.address.state;
      adaptedLead.zip_code = lead.client.address.zip_code;
    }
    
    // Add individual-specific fields if available
    adaptedLead.date_of_birth = lead.client.date_of_birth;
    adaptedLead.gender = lead.client.gender;
    adaptedLead.marital_status = lead.client.marital_status;
    adaptedLead.drivers_license = lead.client.drivers_license;
    adaptedLead.license_state = lead.client.license_state;
    adaptedLead.education_occupation = lead.client.education_occupation;
    adaptedLead.referred_by = lead.client.referred_by;
  }
  
  // If we have status_id but not status, try to derive it
  if (lead.status_id && !lead.status) {
    // This is a simplified mapping - in a real implementation, you would fetch this from the database
    const statusMap: Record<number, LeadStatus> = {
      1: 'New',
      2: 'Contacted',
      3: 'Quoted',
      4: 'Sold',
      5: 'Lost'
    };
    adaptedLead.status = statusMap[lead.status_id] || 'New';
  }
  
  // If we have insurance_type_id but not insurance_type, try to derive it
  if (lead.insurance_type_id && !lead.insurance_type) {
    // This is a simplified mapping - in a real implementation, you would fetch this from the database
    const insuranceTypeMap: Record<number, InsuranceType> = {
      1: 'Auto',
      2: 'Home',
      3: 'Specialty',
      4: 'Commercial',
      5: 'Liability'
    };
    adaptedLead.insurance_type = insuranceTypeMap[lead.insurance_type_id] || 'Auto';
  }
  
  // Ensure we have status and insurance_type for legacy components
  adaptedLead.status_legacy = adaptedLead.status as LeadStatus || 'New';
  adaptedLead.insurance_type_legacy = adaptedLead.insurance_type as InsuranceType || 'Auto';
  
  return adaptedLead;
}

/**
 * Adapts an array of leads from the new normalized schema to a format compatible with the old schema
 */
export function adaptLeadsForLegacyComponents(leads: Lead[]): Lead[] {
  return leads.map(lead => adaptLeadForLegacyComponents(lead));
}

/**
 * Creates a client object from legacy lead fields
 * This is useful when creating a new lead in the new schema format
 */
export function createClientFromLegacyLead(lead: Lead): Client {
  return {
    id: '', // This will be generated by the database
    client_type: 'Individual',
    name: `${lead.first_name || ''} ${lead.last_name || ''}`.trim(),
    email: lead.email,
    phone_number: lead.phone_number,
    date_of_birth: lead.date_of_birth,
    gender: lead.gender,
    marital_status: lead.marital_status,
    drivers_license: lead.drivers_license,
    license_state: lead.license_state,
    education_occupation: lead.education_occupation,
    referred_by: lead.referred_by,
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString()
  };
}
